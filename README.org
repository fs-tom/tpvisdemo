* Cesiumdemo

An exploration of the cesiumjs api from clojurescript.  Working prototype visualizing
entities moving around, doing some realtime plotting with vega as well.  Evolved into a 
responsive single page application with local data processing (client brings their own data), 
and dynamic visuals.  Research software.  Designed to run offline or as hosted self-contained
static website.

** PreRequisites
For the SPA to render correctly (e.g. for the globe GIS layers), you need to have some local layers installed
in the /resources/public/layers directory.

This is basically static imagery for map tiles.  There are two default layers we link to / expect since this
app is designed for offline / hosted usage.  They can be downloaded from:

https://clusterfiles.s3-us-gov-west-1.amazonaws.com/layers.zip

The archive is about 150mb and contains a single folder /layers, which can be extracted or copied to
/resources/public .

Technically, the only layers used in the default app are the Blue Marble tileset, with the Bing tiles
as optional.  


** Development Mode

*** Run application:

#+BEGIN_SRC clojure
lein clean
lein fig -- --build dev --repl
#+END_SRC


Figwheel will automatically push cljs changes to the browser.

Wait a bit, then browse to [http://localhost:9500](http://localhost:9500).

** Production Build

[I have only dev'd with unminified, raw code due to this being a locally hosted app.
 Mileage may vary, particular with using external libs directly...]

#+BEGIN_SRC clojure
lein clean
lein cljsbuild once min
#+END_SRC

** Deployment as a static site

The production files (after the js is compiled from cljs per lein figwheel or lein cljsbuild)
can be copied to any hosting service (e.g. an S3 bucket) and viewed from there.  

Alternately, you can run the project locally (assuming you have the repository, clojure, leiningen,
and the layers mentioned) via the built-in simple webserver lein provides. I could (but have not)
bundle the whole thing as an uberjar where -main simply starts the webserver and serves up files.
Any simple webserver (e.g. node.js, python, java, etc.) can merely serve the files at /resources/public 
and everything should work fine (resources are all relative to web root, and designed for offline use).

For windows users, there is a simple powershell webserver that serves static files 
in /resources/public/server.ps1 .

* Live Demo

There is a live version running at http://cesiumdemo.s3-website-us-gov-west-1.amazonaws.com/ .
Note: there are a decent amount of resources (namely the map layers, but also unminified javascript)
that may take a bit to download on first load.  Later loads should be cached though.

On load, there will be a default horizontal display.  You should see a control panel at the bottom; if you
do not, you may need to zoom out the browser settings (typically ctrl + or ctrl -).  The view should
stretch/shink to accomodate window size as well, primarily dictated by the horizonal width of the browser.
So you can also reorient things if they are missing by resizing the browser window a bit.

Performance seems best with Edge and Chrome.  Firefox webgl rendering isn't as good (but passable).

Click the "demo" button on the bottom for a demonstration with random data and a default color scheme.

* Interesting Notes

As a learning project that evolved into a useful visualization, this repository represents several
minor accomplishments (for me) and perhaps is a roadmap for others.

** Cesium
I ended up wrapping quite a bit of the underlying cesium API, primarily the CZML, datetime, layers, and other
stuff. I started with the Entity API and ended up focusing more on CZML since it fit the clojure/cljs data 
first approach.  There is likely a cljs library to evolve from this, given time and interest.

** Reactive Vega
One of the requirements was a reactive chart or charts synchronized with the GIS animation.  This presented
some interesting challenges, although VEGA was largely up to the task.  I similarly wrapped (and leveraged
some community wrappers for generting schemas) quite a bit of Vega, to include plumbing out the underlying
view API and leveraging signals and hooks to supply information to the charts.  This ended up being 
pretty elegant in cljs, allowing a nice degree of control over the otherwise "static" information the 
declarative VEGA schemes tend to present.  We can turn changes from events into a clojure sequences and
project them into changesets for the various charts, for instance.  From there it's a matter of wiring 
and communication (which reagent handles nicely).

** CSV parsing / data processing
I had to do some browser-based work with CSV.  Previously, I just used a port of my own stuff from SPORK, 
but this time I went with the clojure ecosystem.  Semantic-CSV is pretty nice in this regard, although 
the parser from cljs.csv requires you to autodetect crlf or lf.  The parser included with google's closure
library worked out of the box.

** Discrete Event Sampling / Temporal Sampling

One of the things that popped up was reading a lot of discrete temporal data (events of tstart tstop) and 
querying them over constant samplying frequency.  I had a library to do this (again a piece of SPORK), but
decided to see what cljs had out there.  The library from helins, interval.cljc, worked great.  There was
a minor caveat with the range queries being exclusive instead of inclusive over the end points of intervals
but that was trivially worked around.  Overall, a very nice experience available out of the box.

** Responsive Design
I ended up iterating with layout, sizing, UI, etc. many times with the sponsor.  This was my first
real foray into using CSS and leveraging flexbox.  I think the combination of reagent / flexbox is 
plus responsive components is an excellent way to design flexible frontends for little apps.

** cljs-bean

Trying to introspect objects from the CLJS repl (where I like to live) and reference their docs from official
references is rough in vanilla cljs.  Thankfully, cljs-bean helps you wrap anything in a map-like 
object that includes keys for properties and methods.  This is great for dissecting and exploring 
JS datastructures, as well as uncovering the incantations for efficient interop calls as you walk
though a foreign API.  Excellent library.
